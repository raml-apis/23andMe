#%RAML 0.8
title: 23andMe
version: 1
baseUri: https://api.23andme.com/{version}
securitySchemes:
  - oauth_2_0: !include securitySchemes/oauth_2_0.raml
schemas:
  - usersResponse: !include /schemas/usersResponse-schema.json
  - profileResponse: !include /schemas/profileResponse-schema.json
  - pictureResponse: !include /schemas/pictureResponse-schema.json
  - featureResponse: !include /schemas/featureResponse-schema.json
  - introductionResponse: !include /schemas/introductionResponse-schema.json
  - createIntroductionResponse: !include /schemas/createIntroductionResponse-schema.json
  - genotypeResponse: !include /schemas/genotypeResponse-schema.json
  - phenotypeResponse: !include /schemas/phenotypeResponse-schema.json
  - genomeResponse: !include /schemas/genomeResponse-schema.json
  - haplogroupsResponse: !include /schemas/haplogroupsResponse-schema.json
  - ancestryResponse: !include /schemas/ancestryResponse-schema.json
  - familyMembersResponse: !include /schemas/familyMembersResponse-schema.json
  - neanderthalResponse: !include /schemas/neanderthalResponse-schema.json
  - relativesResponse: !include /schemas/relativesResponse-schema.json
  - risksResponse: !include /schemas/risksResponse-schema.json
  - carriersResponse: !include /schemas/carriersResponse-schema.json
  - drugResponsesResponse: !include /schemas/drugResponsesResponse-schema.json
  - traitsResponse: !include /schemas/traitsResponse-schema.json
  - gfrsResponse: !include /schemas/gfrsResponse-schema.json
  - introductionStateResponse: !include /schemas/introductionStateResponse-schema.json
securedBy: [ oauth_2_0 ]
/user: 
  get: 
    description: |
      Gets the user id, and a list of profiles (an account can have multiple genotyped people) with ids, whether or not they're genotyped.
      
      The optional email parameter can be used to request the email for this account. Requires the "email" scope.
      
      The optional services parameter can be used to request the endpoint to return what services are available to the profiles.
      
      A service model object is made up of a unique service id, a service label, and a user-readable description of the service. All genotyped profiles should have "pgs_ancestry". Customers with access to health data will have "pgs_health". Demo profiles will have no services.
      
      This endpoint is great for using an app anonymously because there is no personally identifying information.
    queryParameters: 
      email: 
      services: 
    responses: 
      200: 
        body: 
          application/json: 
            schema: usersResponse
            example: !include examples/usersResponse-example.json
/names/{profile_id}: 
  get: 
    description: "For the user and user's profile, gets first and last names. If your user wants to remain anonymous, you shouldn't request this scope. You can optionally filter by profile_id to get the names for just that profile."
    responses: 
      200: 
        body: 
          application/json: 
            schema: profileResponse
            example: !include examples/profileResponse-example.json
/profile_picture/{profile_id}: 
  get: 
    description: "Gets the user's profile picture for a few sizes"
    responses: 
      200: 
        body: 
          application/json: 
            schema: pictureResponse
            example: !include examples/pictureResponse-example.json
  post: 
    description: "Uploads a picture, < 5MB, and crops it.  For the POST, set Content-Type: multipart/form-data and upload the image with parameter <image>."
    body: 
      multipart/form-data: 
        formParameters: 
          image: 
            type: file
    responses: 
      201: 
        body: 
          application/json: 
            schema: pictureResponse
            example: !include examples/pictureResponse-example.json
/publish/{profile_id}/{feature_id}: 
  get: 
    description: |
      Users can publish and share certain features publicly, for example on social networks, with a special link. Anyone with the link, if active, can view that person's results for the following feature_ids:
      
      music: DNA Music 
      neanderthal: Neanderthal Ancestry 
      maternal: Maternal Haplogroup 
      composition: Ancestry Composition 
      paternal: Paternal Haplogroup 
    responses: 
      200: 
        body: 
          application/json: 
            schema: featureResponse
            example: !include examples/featureResponse-example.json
  post: 
    description: |
      Users can publish and share certain features publicly, for example on social networks, with a special link. Anyone with the link, if active, can view that person's results for the following feature_ids:
      
      music: DNA Music 
      neanderthal: Neanderthal Ancestry 
      maternal: Maternal Haplogroup 
      composition: Ancestry Composition 
      paternal: Paternal Haplogroup 
    responses: 
      201: 
        body: 
          application/json: 
            schema: featureResponse
            example: !include examples/featureResponse-example.json
  /{link_id}: 
    get: 
      description: |
        Users can publish and share certain features publicly, for example on social networks, with a special link. Anyone with the link, if active, can view that person's results for the following feature_ids:
        
        music: DNA Music 
        neanderthal: Neanderthal Ancestry 
        maternal: Maternal Haplogroup 
        composition: Ancestry Composition 
        paternal: Paternal Haplogroup 
      responses: 
        200: 
          body: 
            application/json: 
              schema: featureResponse
              example: !include examples/featureResponse-example.json
    put: 
      description: Users can publish and share certain features publicly, for example on social networks, with a special link. This method set status to published or unpublished.
      responses: 
        200: 
          body: 
            application/json: 
              schema: featureResponse
              example: !include examples/featureResponse-example.json
/introduction/{profile_id}/{match_id}: 
  patch: 
    description: |
      Users can see the status of introductions between themselves and other relatives as identified by /relatives. If an introduction exists between the two users, the endpoint returns a JSON representation of the introduction and can_send. If can_send is true, the user can send another introduction via a POST /introduction.
      
      Possible values for status are those settable by the PATCH method as well as sent and received. An introduction is sent before being accepted, rejected, read, or cancelled. An introduction is sent and received at exactly the same time depending on whether the person querying is the sender or the recipient.
      
      Statuses listed above are relative to you. For instance, if user B sends an introduction to you, cancels it, and then you query this endpoint, you will find that no introduction exists between you and user B. If user B then queries the endpoint, she will find an introduction between herself and you with the status cancelled.
      
      You may send an introduction if there is no outstanding introduction between you and the user, if you've sent and cancelled an introduction, or if an invitation between you and the user has been rejected. A minimum time interval between introduction resends is also imposed. These cases are abstracted away for you -- just check if can_send is true.
      
      If there is no outstanding introduction between you and the user represented by match_id, then you will receive an empty dict.
    responses: 
      200: 
        body: 
          application/json: 
            schema: introductionResponse
            example: !include examples/introductionResponse-example.json
  post: 
    description: |
      Users can send introductions to other users who we've identified as genetic matches per the /relatives endpoint. The match_id must be a match of the profile_id (it must show up in /relatives endpoint.)
      
      Parameters are message_text and visibility.
      
      message_text may be customized, and defaults to:
      Hi, Through our shared DNA, 23andMe has identified us as relatives. Our predicted relationship is <your_relationship>. Would you like to explore our relationship?
      
      Values for visibility are the same as those of the PATCH method. If no parameter is supplied, visibility defaults to anonymous.
    queryParameters: 
      message_text: 
        description: Introduction message
        default: Hi, Through our shared DNA, 23andMe has identified us as relatives. Our predicted relationship is <your_relationship>. Would you like to explore our relationship?
        example: Hi! Want to explore?
      visibility: 
        description: Visibility
        default: anonymous
        example: genome
    responses: 
      200: 
        body: 
          application/json: 
            schema: createIntroductionResponse
            example: !include examples/createIntroductionResponse-example.json
  get: 
    description: |
      Users can see the status of introductions between themselves and other relatives as identified by /relatives. If an introduction exists between the two users, the endpoint returns a JSON representation of the introduction and can_send. If can_send is true, the user can send another introduction via a POST /introduction.
      
      Possible values for status are those settable by the PATCH method as well as sent and received. An introduction is sent before being accepted, rejected, read, or cancelled. An introduction is sent and received at exactly the same time depending on whether the person querying is the sender or the recipient.
      
      Statuses listed above are relative to you. For instance, if user B sends an introduction to you, cancels it, and then you query this endpoint, you will find that no introduction exists between you and user B. If user B then queries the endpoint, she will find an introduction between herself and you with the status cancelled.
      
      You may send an introduction if there is no outstanding introduction between you and the user, if you've sent and cancelled an introduction, or if an invitation between you and the user has been rejected. A minimum time interval between introduction resends is also imposed. These cases are abstracted away for you -- just check if can_send is true.
      
      If there is no outstanding introduction between you and the user represented by match_id, then you will receive an empty dict.
    responses: 
      200: 
        body: 
          application/json: 
            schema: introductionStateResponse
            example: !include examples/introductionStateResponse-example.json
/genotypes/{profile_id}: 
  get: 
    description: |
      For the user's profile, returns the base-pairs, like AA, for the given locations. The value can have Ds or Is for deletions and insertions (for example, DD or DI). It can be __ if the customer is not on a chip that calls that location, or hasn't yet unlocked their call since it corresponds to a sensitive report. It can be -- if the customer is on a chip that calls that location, but we could not determine it. To keep consistency with the /genomes endoint, which always returns two base pairs, hemizygous calls (such as on X-linked genes in males) will also return two base pairs. 
      
      The scope of your token must include each location you request (i.e., getting the below data requires a scope of at least rs3094315 i3000001). This list of SNPs (31MB) shows which SNPs our customers are genotyped for. 
      
      The unfiltered parameter can be used for completely sex-unfiltered data. 
      
      The format parameter can be used to alter the JSON output format of this endpoint. 
      
      Since this is a GET endpoint, you may hit the browser-imposed URL limit with a lot of SNPs. We recommend splitting your requests into 100-SNP chunks.
    queryParameters: 
      locations: 
      unfiltered: 
      format: 
        example: embedded
    responses: 
      200: 
        body: 
          application/json: 
            schema: genotypeResponse
            example: !include examples/genotypeResponse-example.json
/phenotypes/{profile_id}/{phenotype_id}: 
  get: 
    description: |
      For the user's profile, returns the requested phenotype.
      For the /phenotypes read and write endpoints, your phenotype_id can be any of the following:
      
      family_tree_url: family tree url
      date_of_birth: date of birth (YYYY-MM-DD)
      weight_g: weight in grams
      height_mm: height in millimeters
      sex: sex
    responses: 
      200: 
        body: 
          application/json: 
            schema: phenotypeResponse
            example: !include examples/phenotypeResponse-example.json
/genomes/{profile_id}: 
  get: 
    description: |
      Returns the entire profile's genome as a packed string of base pairs "AACTGA...". This ~2MB request returns over a million SNP locations, so you must specify profile_id. See the /genotypes endpoint for possible values. Each SNP is represented with two base pairs, and to know which SNP corresponds to which index, see this key. 
      
      The unfiltered parameter can be used for completely sex-unfiltered data. 
      
      When our genotyping chip is upgraded, the packed string and corresponding key will grow, but the changes will be backwards-compatible additions.
    queryParameters: 
      unfiltered: 
        type: boolean
        example: true
    responses: 
      200: 
        body: 
          application/json: 
            schema: genomeResponse
            example: !include examples/genomeResponse-example.json
/haplogroups/{profile_id}: 
  get: 
    description: |
      For the user's profile, gets maternal and paternal haplogroups, as well as terminal SNPs. Maternal terminal SNPs include the rsid and rCRS reference position, while the paternal ones include the rsid and ISOGG SNP.
      
      Note: if the profile belongs to a female, the paternal (y) haplogroup and terminal SNP information will be null.
    responses: 
      200: 
        body: 
          application/json: 
            schema: haplogroupsResponse
            example: !include examples/haplogroupsResponse-example.json
/ancestry/{profile_id}: 
  get: 
    description: |
      Ancestral breakdown for the user's profile. Each population has an absolute proportion of the genome. A population with sub_populations has an unassigned proportion — the ancestry we couldn't classify in it. 
      
      threshold is optional, default 0.51 and range (0.5, 1.0) exclusive. 0.51 means a speculative estimate, 0.75 standard, and 0.90 conservative. A higher threshold would increase the unassigned proportions, a lower would speculate. 
      
      If the user's ancestry hasn't been computed yet, you'll see "ancestry": null.
    responses: 
      200: 
        body: 
          application/json: 
            schema: ancestryResponse
            example: !include examples/ancestryResponse-example.json
/family_members: 
  get: 
    description: |
      All Family Members in an account's family tree as entered in the family tree tool. Every profile has a family tree member node created automatically, so even users who have never used the family tree tool will have some data here.
      
      The response is formed to return the account id, and pagination information limit offset and count. Since the account can have thousands of family tree members, limit defaults to 10, and offset to 0. You can override the limit (or not limit it at all with limit = 0, but be careful, the user may have thousands of family tree members). count gives the total number of matches after filtering. The limit and offset values in the response will represent the pagination values used by this request.
      
      Family Members:
      A family member in the members array will have a member id field id. Any family member that is associated with a profile will also have non empty profile_id. The sex field can be set to "m" or "f" to represent male and female respectively. The adopted and deceased fields will both contain true or false. The first_name, middle_name, last_name, birth_surname, name_suffix and nickname fields will only be sent if the account has given you the 'names' scope. The partners and parents fields are arrays of member ids. Finally, the events field contains an array of events for the family member as shown in the example below.
    queryParameters: 
      limit: 
        default: 10
        example: x
      offset: 
        default: 0
        example: y
      count: 
    responses: 
      200: 
        body: 
          application/json: 
            schema: familyMembersResponse
            example: !include examples/familyMembersResponse-example.json
/neanderthal/{profile_id}: 
  get: 
    description: "Estimated genome-wide proportion of Neanderthal ancestry for the user's profile. Most users have between 0.01 and 0.04 Neanderthal ancestry -- read a full explanation of the science. proportion is -1 for un-genotyped (or as-of-yet uncomputed) profiles."
    responses: 
      200: 
        body: 
          application/json: 
            schema: neanderthalResponse
            example: !include examples/neanderthalResponse-example.json
/relatives/{profile_id}: 
  get: 
    description: |
      Relatives on 23andMe, for the user's profile. shared_segments is the total number of shared IBD segments; similarity is the actual proportion (1.00 being you, or an identical twin). maternal/paternal_side are True if this match is a relative from your mom or dad's side. range is defined if we couldn't pinpoint the relatedness of the match.
      
      match_id is a unique identifier for matches for a given profile, but not across profiles. For example, if profile A has a relative C1, and profile B has relative C2, then any C1.match_id = C2.match_id is coincidental and does not mean C1 and C2 represent the same person. We cannot expose globally unique match_ids. match_id is null if the match is you.
      
      Since you could have thousands of matches, limit defaults to 10, and offset to 0. You can override the limit (or not limit it at all with limit = 0, but be careful, the user may have thousands of relatives). count gives the total number of matches after filtering. Results are sorted by updated, descending. You can also get results that have been updated or added since a timestamp.
      
      You can also filter matches by their intro_status and share_status. Note that you will have to URL-encode these parameters (i.e., Introduction%20Sent). The possible values are:
      
      intro_status
      Introduction Received
      Introduction Accepted
      Introduction Sent
      Introduction Cancelled
      Introduction Declined
      share_status
      Owned Profile
      Sharing Genomes
      Public Match
      
      You can provide an optional match_id parameter to limit the results returned to that of an individual match. In this case, match_id overrides any other conflicting parameters. For instance, if you provide both a match_id and a since parameter, the match's information will be returned regardless of whether the match was updated or added since the timestamp specified by the since parameter. The count returned will be 1 when the match_id parameter is specified. Example usage is as follows: https://api.23andme.com/1/relatives/c44.../?match_id=48f...
    queryParameters: 
      limit: 
        example: x
      offset: 
        example: y
      since: 
        example: 1348699925
      share_status: 
        example: z
      intro_status: 
        example: a
    responses: 
      200: 
        body: 
          application/json: 
            schema: relativesResponse
            example: !include examples/relativesResponse-example.json
  /{match_id}: 
    patch: 
      description: Updates a relative match. In our DNA Relatives feature, we calculate a predicted relationship based on your overlapping DNA segments. But if you know for sure, you can update the match with a known user_relationship_code (see below). You can also add notes about the match.
      queryParameters: 
        notes: 
          description: Add notes about the match.
          example: nice
        user_relationship_code: 
          description: |
            If you know for sure, you can update the match with a known user_relationship_code (see below).
            
            0 You
            1 Identical Twin
            2 Father
            3 Mother
            4 Son
            5 Daughter
            6 Brother
            7 Sister
            8 Half Brother
            9 Half Sister
            10 Grandfather
            11 Grandmother
            12 Grandson
            13 Granddaughter
            14 Uncle
            15 Aunt
            16 Nephew
            17 Niece
            18 Great Grandfather
            19 Great Grandson
            20 Great Grandmother
            21 Great Granddaughter
            22 Great Uncle
            23 Great Aunt
            24 Great Nephew
            25 Great Niece
            26 1st Cousin
            27 1st Cousin, Once Removed
            28 1st Cousin, Twice Removed
            29 2nd Cousin
            30 2nd Cousin, Once Removed
            31 2nd Cousin, Twice Removed
            32 3rd Cousin
            33 3rd Cousin, Once Removed
            34 3rd Cousin, Twice Removed
            35 4th Cousin
            38 5th Cousin
            41 6th Cousin
            44 Distant Cousin
      responses: 
        204: 
/risks/{profile_id}: 
  get: 
    description: "Our analysis for each profile's lifetime risk of these diseases (starred reports). population_risk is the average risk for the population for which the analysis applies, and risk is the profile's risk."
    responses: 
      200: 
        body: 
          application/json: 
            schema: risksResponse
            example: !include examples/risksResponse-example.json
/carriers/{profile_id}: 
  get: 
    description: |
      Our analysis of whether or not each profile is a carrier for these diseases (starred reports). The person has 0, 1, or 2 mutations, or null if they're not analyzed at any of the markers. Normally, with one mutation, the person is considered a "carrier" and can pass the mutation to children; with two, the person is likely to be affected by the disease.
    responses: 
      200: 
        body: 
          application/json: 
            schema: carriersResponse
            example: !include examples/carriersResponse-example.json
/drug_responses/{profile_id}: 
  get: 
    description: "Our analysis of how each profile responds to these drugs (starred reports). status is reduced, typical, or increased for a person, not_applicable if the drug is not applicable to them (e.g., the oral contraceptives report is for women only), or null if they're not analyzed at any of the markers."
    responses: 
      200: 
        body: 
          application/json: 
            schema: drugResponsesResponse
            example: !include examples/drugResponsesResponse-example.json
/traits/{profile_id}: 
  get: 
    description: "Our analysis for each profile for these traits (starred reports). trait is a value in possible_traits, or null if the profile's not analyzed at those markers."
    responses: 
      200: 
        body: 
          application/json: 
            schema: traitsResponse
            example: !include examples/traitsResponse-example.json
/grfs/{profile_id}: 
  get: 
    description: Our analysis for each profile for genetic risk factors. mutations is positive if the profile contains a mutation which corresponds to the condition denoted by description.
    responses: 
      200: 
        body: 
          application/json: 
            schema: gfrsResponse
            example: !include examples/gfrsResponse-example.json
/demo: 
  /user: 
    get: 
      description: |
        Gets the user id, and a list of profiles (an account can have multiple genotyped people) with ids, whether or not they're genotyped.
        
        The optional email parameter can be used to request the email for this account. Requires the "email" scope.
        
        The optional services parameter can be used to request the endpoint to return what services are available to the profiles.
        
        A service model object is made up of a unique service id, a service label, and a user-readable description of the service. All genotyped profiles should have "pgs_ancestry". Customers with access to health data will have "pgs_health". Demo profiles will have no services.
        
        This endpoint is great for using an app anonymously because there is no personally identifying information.
      queryParameters: 
        email: 
        services: 
      responses: 
        200: 
          body: 
            application/json: 
              schema: usersResponse
              example: !include examples/usersResponse-example.json
  /names/{profile_id}: 
    get: 
      description: "For the user and user's profile, gets first and last names. If your user wants to remain anonymous, you shouldn't request this scope. You can optionally filter by profile_id to get the names for just that profile."
      responses: 
        200: 
          body: 
            application/json: 
              schema: profileResponse
              example: !include examples/profileResponse-example.json
  /introduction/{profile_id}/{match_id}: 
    patch: 
      description: |
        Users can see the status of introductions between themselves and other relatives as identified by /relatives. If an introduction exists between the two users, the endpoint returns a JSON representation of the introduction and can_send. If can_send is true, the user can send another introduction via a POST /introduction.
        
        Possible values for status are those settable by the PATCH method as well as sent and received. An introduction is sent before being accepted, rejected, read, or cancelled. An introduction is sent and received at exactly the same time depending on whether the person querying is the sender or the recipient.
        
        Statuses listed above are relative to you. For instance, if user B sends an introduction to you, cancels it, and then you query this endpoint, you will find that no introduction exists between you and user B. If user B then queries the endpoint, she will find an introduction between herself and you with the status cancelled.
        
        You may send an introduction if there is no outstanding introduction between you and the user, if you've sent and cancelled an introduction, or if an invitation between you and the user has been rejected. A minimum time interval between introduction resends is also imposed. These cases are abstracted away for you -- just check if can_send is true.
        
        If there is no outstanding introduction between you and the user represented by match_id, then you will receive an empty dict.
      responses: 
        200: 
          body: 
            application/json: 
              schema: introductionStateResponse
              example: !include examples/introductionStateResponse-example.json
    post: 
      description: |
        Users can send introductions to other users who we've identified as genetic matches per the /relatives endpoint. The match_id must be a match of the profile_id (it must show up in /relatives endpoint.)
        
        Parameters are message_text and visibility.
        
        message_text may be customized, and defaults to:
        Hi, Through our shared DNA, 23andMe has identified us as relatives. Our predicted relationship is <your_relationship>. Would you like to explore our relationship?
        
        Values for visibility are the same as those of the PATCH method. If no parameter is supplied, visibility defaults to anonymous.
      queryParameters: 
        message_text: 
          description: Introduction message
          default: Hi, Through our shared DNA, 23andMe has identified us as relatives. Our predicted relationship is <your_relationship>. Would you like to explore our relationship?
          example: Hi! Want to explore?
        visibility: 
          description: Visibility
          default: anonymous
          example: genome
      responses: 
        200: 
          body: 
            application/json: 
              schema: createIntroductionResponse
              example: !include examples/createIntroductionResponse-example.json
  /genotypes/{profile_id}: 
    get: 
      description: |
        For the user's profile, returns the base-pairs, like AA, for the given locations. The value can have Ds or Is for deletions and insertions (for example, DD or DI). It can be __ if the customer is not on a chip that calls that location, or hasn't yet unlocked their call since it corresponds to a sensitive report. It can be -- if the customer is on a chip that calls that location, but we could not determine it. To keep consistency with the /genomes endoint, which always returns two base pairs, hemizygous calls (such as on X-linked genes in males) will also return two base pairs. 
        
        The scope of your token must include each location you request (i.e., getting the below data requires a scope of at least rs3094315 i3000001). This list of SNPs (31MB) shows which SNPs our customers are genotyped for. 
        
        The unfiltered parameter can be used for completely sex-unfiltered data. 
        
        The format parameter can be used to alter the JSON output format of this endpoint. 
        
        Since this is a GET endpoint, you may hit the browser-imposed URL limit with a lot of SNPs. We recommend splitting your requests into 100-SNP chunks.
      queryParameters: 
        locations: 
        unfiltered: 
        format: 
          example: embedded
      responses: 
        200: 
          body: 
            application/json: 
              schema: genotypeResponse
              example: !include examples/genotypeResponse-example.json
  /phenotypes/{profile_id}/{phenotype_id}: 
    get: 
      description: |
        For the user's profile, returns the requested phenotype.
        For the /phenotypes read and write endpoints, your phenotype_id can be any of the following:
        
        family_tree_url: family tree url
        date_of_birth: date of birth (YYYY-MM-DD)
        weight_g: weight in grams
        height_mm: height in millimeters
        sex: sex
      responses: 
        200: 
          body: 
            application/json: 
              schema: phenotypeResponse
              example: !include examples/phenotypeResponse-example.json
  /genomes/{profile_id}: 
    get: 
      description: |
        Returns the entire profile's genome as a packed string of base pairs "AACTGA...". This ~2MB request returns over a million SNP locations, so you must specify profile_id. See the /genotypes endpoint for possible values. Each SNP is represented with two base pairs, and to know which SNP corresponds to which index, see this key. 
        
        The unfiltered parameter can be used for completely sex-unfiltered data. 
        
        When our genotyping chip is upgraded, the packed string and corresponding key will grow, but the changes will be backwards-compatible additions.
      queryParameters: 
        unfiltered: 
          type: boolean
          example: true
      responses: 
        200: 
          body: 
            application/json: 
              schema: genomeResponse
              example: !include examples/genomeResponse-example.json
  /haplogroups/{profile_id}: 
    get: 
      description: |
        For the user's profile, gets maternal and paternal haplogroups, as well as terminal SNPs. Maternal terminal SNPs include the rsid and rCRS reference position, while the paternal ones include the rsid and ISOGG SNP.
        
        Note: if the profile belongs to a female, the paternal (y) haplogroup and terminal SNP information will be null.
      responses: 
        200: 
          body: 
            application/json: 
              schema: haplogroupsResponse
              example: !include examples/haplogroupsResponse-example.json
  /ancestry/{profile_id}: 
    get: 
      description: |
        Ancestral breakdown for the user's profile. Each population has an absolute proportion of the genome. A population with sub_populations has an unassigned proportion — the ancestry we couldn't classify in it. 
        
        threshold is optional, default 0.51 and range (0.5, 1.0) exclusive. 0.51 means a speculative estimate, 0.75 standard, and 0.90 conservative. A higher threshold would increase the unassigned proportions, a lower would speculate. 
        
        If the user's ancestry hasn't been computed yet, you'll see "ancestry": null.
      responses: 
        200: 
          body: 
            application/json: 
              schema: ancestryResponse
              example: !include examples/ancestryResponse-example.json
  /family_members: 
    get: 
      description: |
        All Family Members in an account's family tree as entered in the family tree tool. Every profile has a family tree member node created automatically, so even users who have never used the family tree tool will have some data here.
        
        The response is formed to return the account id, and pagination information limit offset and count. Since the account can have thousands of family tree members, limit defaults to 10, and offset to 0. You can override the limit (or not limit it at all with limit = 0, but be careful, the user may have thousands of family tree members). count gives the total number of matches after filtering. The limit and offset values in the response will represent the pagination values used by this request.
        
        Family Members:
        A family member in the members array will have a member id field id. Any family member that is associated with a profile will also have non empty profile_id. The sex field can be set to "m" or "f" to represent male and female respectively. The adopted and deceased fields will both contain true or false. The first_name, middle_name, last_name, birth_surname, name_suffix and nickname fields will only be sent if the account has given you the 'names' scope. The partners and parents fields are arrays of member ids. Finally, the events field contains an array of events for the family member as shown in the example below.
      queryParameters: 
        limit: 
          default: 10
          example: x
        offset: 
          default: 0
          example: y
        count: 
      responses: 
        200: 
          body: 
            application/json: 
              schema: familyMembersResponse
              example: !include examples/familyMembersResponse-example.json
  /neanderthal/{profile_id}: 
    get: 
      description: "Estimated genome-wide proportion of Neanderthal ancestry for the user's profile. Most users have between 0.01 and 0.04 Neanderthal ancestry -- read a full explanation of the science. proportion is -1 for un-genotyped (or as-of-yet uncomputed) profiles."
      responses: 
        200: 
          body: 
            application/json: 
              schema: neanderthalResponse
              example: !include examples/neanderthalResponse-example.json
  /risks/{profile_id}: 
    get: 
      description: "Our analysis for each profile's lifetime risk of these diseases (starred reports). population_risk is the average risk for the population for which the analysis applies, and risk is the profile's risk."
      responses: 
        200: 
          body: 
            application/json: 
              schema: risksResponse
              example: !include examples/risksResponse-example.json
  /carriers/{profile_id}: 
    get: 
      description: |
        Our analysis of whether or not each profile is a carrier for these diseases (starred reports). The person has 0, 1, or 2 mutations, or null if they're not analyzed at any of the markers. Normally, with one mutation, the person is considered a "carrier" and can pass the mutation to children; with two, the person is likely to be affected by the disease.
      responses: 
        200: 
          body: 
            application/json: 
              schema: carriersResponse
              example: !include examples/carriersResponse-example.json
  /drug_responses/{profile_id}: 
    get: 
      description: "Our analysis of how each profile responds to these drugs (starred reports). status is reduced, typical, or increased for a person, not_applicable if the drug is not applicable to them (e.g., the oral contraceptives report is for women only), or null if they're not analyzed at any of the markers."
      responses: 
        200: 
          body: 
            application/json: 
              schema: drugResponsesResponse
              example: !include examples/drugResponsesResponse-example.json
  /traits/{profile_id}: 
    get: 
      description: "Our analysis for each profile for these traits (starred reports). trait is a value in possible_traits, or null if the profile's not analyzed at those markers."
      responses: 
        200: 
          body: 
            application/json: 
              schema: traitsResponse
              example: !include examples/traitsResponse-example.json
  /grfs/{profile_id}: 
    get: 
      description: Our analysis for each profile for genetic risk factors. mutations is positive if the profile contains a mutation which corresponds to the condition denoted by description.
      responses: 
        200: 
          body: 
            application/json: 
              schema: gfrsResponse
              example: !include examples/gfrsResponse-example.json
  /relatives/{profile_id}: 
    get: 
      description: |
        Relatives on 23andMe, for the user's profile. shared_segments is the total number of shared IBD segments; similarity is the actual proportion (1.00 being you, or an identical twin). maternal/paternal_side are True if this match is a relative from your mom or dad's side. range is defined if we couldn't pinpoint the relatedness of the match.
        
        match_id is a unique identifier for matches for a given profile, but not across profiles. For example, if profile A has a relative C1, and profile B has relative C2, then any C1.match_id = C2.match_id is coincidental and does not mean C1 and C2 represent the same person. We cannot expose globally unique match_ids. match_id is null if the match is you.
        
        Since you could have thousands of matches, limit defaults to 10, and offset to 0. You can override the limit (or not limit it at all with limit = 0, but be careful, the user may have thousands of relatives). count gives the total number of matches after filtering. Results are sorted by updated, descending. You can also get results that have been updated or added since a timestamp.
        
        You can also filter matches by their intro_status and share_status. Note that you will have to URL-encode these parameters (i.e., Introduction%20Sent). The possible values are:
        
        intro_status
        Introduction Received
        Introduction Accepted
        Introduction Sent
        Introduction Cancelled
        Introduction Declined
        share_status
        Owned Profile
        Sharing Genomes
        Public Match
        
        You can provide an optional match_id parameter to limit the results returned to that of an individual match. In this case, match_id overrides any other conflicting parameters. For instance, if you provide both a match_id and a since parameter, the match's information will be returned regardless of whether the match was updated or added since the timestamp specified by the since parameter. The count returned will be 1 when the match_id parameter is specified. Example usage is as follows: https://api.23andme.com/1/relatives/c44.../?match_id=48f...
      queryParameters: 
        limit: 
          example: x
        offset: 
          example: y
        since: 
          example: 1348699925
        share_status: 
          example: z
        intro_status: 
          example: a
      responses: 
        200: 
          body: 
            application/json: 
              schema: relativesResponse
              example: !include examples/relativesResponse-example.json
    /{match_id}: 
      patch: 
        description: Updates a relative match. In our DNA Relatives feature, we calculate a predicted relationship based on your overlapping DNA segments. But if you know for sure, you can update the match with a known user_relationship_code (see below). You can also add notes about the match.
        queryParameters: 
          notes: 
            description: Add notes about the match.
            example: nice
          user_relationship_code: 
            description: |
              If you know for sure, you can update the match with a known user_relationship_code (see below).
              
              0 You
              1 Identical Twin
              2 Father
              3 Mother
              4 Son
              5 Daughter
              6 Brother
              7 Sister
              8 Half Brother
              9 Half Sister
              10 Grandfather
              11 Grandmother
              12 Grandson
              13 Granddaughter
              14 Uncle
              15 Aunt
              16 Nephew
              17 Niece
              18 Great Grandfather
              19 Great Grandson
              20 Great Grandmother
              21 Great Granddaughter
              22 Great Uncle
              23 Great Aunt
              24 Great Nephew
              25 Great Niece
              26 1st Cousin
              27 1st Cousin, Once Removed
              28 1st Cousin, Twice Removed
              29 2nd Cousin
              30 2nd Cousin, Once Removed
              31 2nd Cousin, Twice Removed
              32 3rd Cousin
              33 3rd Cousin, Once Removed
              34 3rd Cousin, Twice Removed
              35 4th Cousin
              38 5th Cousin
              41 6th Cousin
              44 Distant Cousin
        responses: 
          204: 
documentation: 
  - title: Headline
    content: !include docs/api/headline.md
